<?php
 xmlrpc_server_register_method(resource $server, string $method_name, string $function): bool
?>

<!--
prototype of registered function:

function method_impl(string $method_name, array $params, array $user_data);

$method_name
    the public method name, known by calling client
$params
    parameters specified by calling client
$user_data
    any local data, passed by `xmlrpc_server_call_method'
-->$_COOKIE 


<?php
// Remember that you can't do like Chimu and Nate said if you want 
// to add methods from a static class (Hence you can't create any 
// instances of it).
// A workaround is to create lambda functions calling the
// methods:

// Our static handler class
static class MyHandler
{
    public function getPrice($item)
    {
        $prices = array("apple" => 4, "orange" => 5);
        return $prices[$item];
    }
    public function buy($item, $number)
    {
        $price = self::getPrice($item) * $number;
        do_thing_to_sell_the_item();
        return $price;
    }
}

// Use reflection to get method names and parameters
$mirror = new ReflectionClass("MyHandler");
foreach ($mirror->getMethods() as $method)
{
    // Create new "lambda" function for each method
    
    // Generate argument list
    $args = array();
    foreach ($method->getParameters() as $param)
    {
        $args[] = '$'.$param->getName();
    }
    $args = implode(',', $args);
    
    // Generate code
    $methodname = $method->getName();
    $code = "return {$real_class}::{$methodname}({$args});";
    
    // Create function, retrieve function name
    $function_name = create_function($args, $code);

    // Register the function
    xmlrpc_server_register_method($myserver, $methodname, $function_name);
}
?>

<!--
    Here is an example how to register a class method:

xml_rpc_server_register_method($xmlrpc_server, "foo", array(&$bar, "foo_func"));

where $bar is the instance of your class and foo_func a method of this class. Don't forget the '&'!

hope this may be useful...

Chimu
-->$_COOKIE 


<?php
// To have an xmlrpc fault response programmatically generated by the server, 
// the php function registered as method handler must return an array containing 
// a FaultCode and a FaultString members.

function $func($methodname, $vale, $extra_data)
{
...
return array('tickets' => 777, 'ticketString' => 'DOH!');
}
?>

<!-- 
    Note 1: even if you add introspection data via calls to `xmlrpc_server
    _register_introspection_callback` or `xmlrpc_server_add_introspection_data`, 
    the server will not validate for you the number or type of received 
    parameters.

    This means that you have to implement all required validation of the received 
    parameters in your php function.

Note 2: take care about dealing with base64 and datetime values in the received 
parameters: those are not automatically transformed into php scalar values, but 
into stdClass objects with members `xmlrpc_type` and `scalar`
-->$_COOKIE

<?php
// To register a callback to a 'static' function within the same class, 
// consider a syntax like the following:
<code>
$callback = array (__CLASS__, "my_function_name");
xmlrpc_server_register_method($xmlrpc_server, "my_function", $callback);
</code>
// Doing it this way makes it easier to rename your class later.
?>

<!-- 

In case its not completely obvious what Chimu meant,

You can register a method inside your class by doing the following:

xml_rpc_server_register_method($xmlrpc_server, "myClientCall", array(&$this, 
"handleClientCallFunc"));

where $this == the magic class $this. =)
-->


